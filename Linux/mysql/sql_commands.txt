_1.更新数据字段(数据集合)
	UPDATE m_o_survey_order  t1 INNER JOIN

	(SELECT
		o.id,
		GROUP_CONCAT(d.customer_name) AS customer_names
	FROM
		m_o_survey_order AS o
	LEFT JOIN m_o_survey_customer_detail AS d ON o.id = d.order_id
	WHERE
		o.customer_names = ''
	AND d.customer_name != ''
	GROUP BY
		o.id) t2 ON t1.id=t2.id SET t1.customer_names=t2.customer_names;
_2. str存在strlist中 
    FIND_IN_SET(str,strlist)
_3. 将查询结果插入到表中
	insert into tab (a,b,c) 
	select * from tab2
_4.查看表名的字段
	information_schema系统库(mysql相关的信息都能在系统库中找到)
	SELECT COLUMN_NAME FROM information_schema.COLUMNS where table_name = 'tab_name';	
_5.复制一张表
   CREATE TABLE abc AS
   SELECT * FROM test t 	会把test的结构和数据都会创建到abc中
_6.创建一张临时表
   CREATE TEMPORARY TABLE abc
   SELECT * FROM m_b_address

   SHOW CREATE TABLE abc;   #  查看创建表的sql
_7.查看表的列
   DESC cp_bets ; 	
   SHOW columns FROM  cp_bets ;
_8.explain sql语句 (查看sql语句,看索引是否生效)   
   结果如下:
   	table：显示这一行的数据是关于哪张表的

	type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL

	possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句

	key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引

	key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好

	ref：显示索引的哪一列被使用了，如果可能的话，是一个常数

	rows：MYSQL认为必须检查的用来返回请求数据的行数

	extra：关于MYSQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢
